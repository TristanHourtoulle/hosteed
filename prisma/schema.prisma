generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model TypeRent {
  id          String      @id @default(cuid())
  name        String
  description String
  isHotelType Boolean     @default(false) // Indique si ce type fonctionne comme un hôtel
  products    Product[]
  commission  Commission? // Nouvelle relation: Une commission par type de logement
}

model Equipment {
  id       String    @id @default(cuid())
  name     String
  icon     String    @default("CheckCircle") // Nom de l'icône Lucide
  products Product[] @relation("EquipmentToProduct")
}

model Services {
  id       String    @id @default(cuid())
  name     String
  products Product[] @relation("ProductToServices")
}

// Nouveaux modèles pour la gestion des services et extras

model IncludedService {
  id          String    @id @default(cuid())
  name        String
  description String?
  icon        String? // Nom de l'icône pour l'affichage
  userId      String? // Si null = service global, si défini = service personnel
  products    Product[] @relation("ProductToIncludedService")
  user        User?     @relation("UserIncludedServices", fields: [userId], references: [id], onDelete: Cascade)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
}

model ProductExtra {
  id          String         @id @default(cuid())
  name        String
  description String?
  priceEUR    Float
  priceMGA    Float
  type        ExtraPriceType
  userId      String? // Si null = extra global, si défini = extra personnel
  products    Product[]      @relation("ProductToProductExtra")
  rentExtras  RentExtra[] // Relation avec les réservations
  user        User?          @relation("UserExtras", fields: [userId], references: [id], onDelete: Cascade)
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt
}

model PropertyHighlight {
  id          String    @id @default(cuid())
  name        String
  description String?
  icon        String? // Nom de l'icône pour l'affichage
  userId      String? // Si null = highlight global, si défini = highlight personnel
  products    Product[] @relation("ProductToPropertyHighlight")
  user        User?     @relation("UserHighlights", fields: [userId], references: [id], onDelete: Cascade)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
}

// Modèle pour associer les extras aux réservations
model RentExtra {
  id         String       @id @default(cuid())
  rentId     String
  extraId    String
  quantity   Int          @default(1)
  totalPrice Float
  rent       Rent         @relation(fields: [rentId], references: [id], onDelete: Cascade)
  extra      ProductExtra @relation(fields: [extraId], references: [id], onDelete: Cascade)
  createdAt  DateTime     @default(now())

  @@unique([rentId, extraId])
}

enum ExtraPriceType {
  PER_DAY // par jour
  PER_PERSON // par personne
  PER_DAY_PERSON // par jour et par personne
  PER_BOOKING // par réservation
}

model Meals {
  id       String    @id @default(cuid())
  name     String
  products Product[] @relation("MealsToProduct")
}

model TypeRoom {
  id          String    @id @default(cuid())
  name        String
  description String
  products    Product[] @relation("ProductToTypeRoom")
}

model Security {
  id       String    @id @default(cuid())
  name     String
  products Product[] @relation("ProductToSecurity")
}

model Rules {
  id              String  @id @default(cuid())
  productId       String
  smokingAllowed  Boolean @default(false)
  petsAllowed     Boolean @default(false)
  eventsAllowed   Boolean @default(false)
  checkInTime     String  @default("15:00")
  checkOutTime    String  @default("11:00")
  selfCheckIn     Boolean @default(false)
  selfCheckInType String?
  product         Product @relation(fields: [productId], references: [id], onDelete: Cascade)
}

model Product {
  id               String            @id @default(cuid())
  name             String
  description      String
  address          String
  basePrice        String
  priceMGA         String
  room             BigInt?
  bathroom         BigInt?
  arriving         Int
  leaving          Int
  autoAccept       Boolean
  equipement       BigInt?
  meal             BigInt?
  services         BigInt?
  security         BigInt?
  minRent          BigInt?
  maxRent          BigInt?
  advanceRent      BigInt?
  delayTime        BigInt?
  categories       BigInt
  minPeople        BigInt?
  maxPeople        BigInt?
  commission       Int               @default(0)
  validate         ProductValidation @default(NotVerified)
  userManager      BigInt
  typeId           String
  phone            String
  phoneCountry     String            @default("MG")
  latitude         Float
  longitude        Float
  certified        Boolean           @default(false)
  contract         Boolean           @default(false)
  sizeRoom         Int?
  availableRooms   Int? // Nombre de chambres disponibles pour les hôtels
  options          Options[]
  type             TypeRent          @relation(fields: [typeId], references: [id])
  user             User[]
  rents            Rent[]
  reviews          Review[]
  specificPrices   SpecificPrices[]
  specificRequests SpecificRequest[]
  equipments       Equipment[]       @relation("EquipmentToProduct")
  img              Images[]          @relation("ImagesToProduct")
  mealsList        Meals[]           @relation("MealsToProduct")
  securities       Security[]        @relation("ProductToSecurity")
  servicesList     Services[]        @relation("ProductToServices")
  typeRoom         TypeRoom[]        @relation("ProductToTypeRoom")
  discount         Discount[]
  favorites        Favorite[]
  rules            Rules[]
  nearbyPlaces     NearbyPlace[]
  transportOptions TransportOption[]
  propertyInfo     PropertyInfo?

  UnAvailableProduct UnAvailableProduct[]

  hotel hotel[]

  PromotedProduct PromotedProduct[]

  // Nouvelles relations pour services, extras et points forts
  includedServices IncludedService[]   @relation("ProductToIncludedService")
  extras           ProductExtra[]      @relation("ProductToProductExtra")
  highlights       PropertyHighlight[] @relation("ProductToPropertyHighlight")

  // Nouveaux champs pour la validation améliorée
  validationComments ValidationComment[]
  validationHistory  ValidationHistory[]

  // Draft product support for modification workflow
  originalProductId String? // Reference to original product if this is a draft
  isDraft           Boolean   @default(false) // Flag to identify draft products
  originalProduct   Product?  @relation("ProductDraft", fields: [originalProductId], references: [id], onDelete: Cascade)
  draftProducts     Product[] @relation("ProductDraft") // Draft versions of this product

  SpecialPrices SpecialPrices[]

  // Promotions system
  promotions ProductPromotion[] @relation("ProductPromotions")

  // Performance indexes
  @@index([validate])
  @@index([userManager])
  @@index([typeId])
  @@index([latitude, longitude])
  @@index([certified])
  @@index([validate, certified])
  @@index([userManager, validate])
  @@index([isDraft])
  @@index([originalProductId])
  // Critical search performance indexes
  @@index([validate, isDraft])
  @@index([validate, isDraft, typeId])
  @@index([validate, isDraft, certified])
  @@index([basePrice])
  @@index([autoAccept])
  @@index([minPeople, maxPeople])
  @@index([name])
  @@index([address])
  @@index([description])
}

// Nouveau modèle pour les commentaires de validation
model ValidationComment {
  id         String                  @id @default(cuid())
  productId  String
  adminId    String
  section    ValidationSection // Section de l'annonce commentée
  comment    String // Commentaire de l'admin
  status     ValidationCommentStatus @default(PENDING)
  createdAt  DateTime                @default(now())
  updatedAt  DateTime                @updatedAt
  resolvedAt DateTime? // Date de résolution
  resolvedBy String? // ID de la personne qui a résolu

  product  Product @relation(fields: [productId], references: [id], onDelete: Cascade)
  admin    User    @relation("AdminComments", fields: [adminId], references: [id])
  resolver User?   @relation("CommentResolver", fields: [resolvedBy], references: [id])

  // Performance indexes
  @@index([productId])
  @@index([adminId])
  @@index([status])
  @@index([createdAt])
}

// Nouveau modèle pour l'historique des validations
model ValidationHistory {
  id             String            @id @default(cuid())
  productId      String
  previousStatus ProductValidation
  newStatus      ProductValidation
  adminId        String? // ID de l'admin qui a fait le changement
  hostId         String? // ID de l'hôte si c'est lui qui a fait une modification
  reason         String? // Raison du changement
  changes        Json? // Détails des modifications apportées
  createdAt      DateTime          @default(now())

  product Product @relation(fields: [productId], references: [id], onDelete: Cascade)
  admin   User?   @relation("ValidationAdmin", fields: [adminId], references: [id])
  host    User?   @relation("ValidationHost", fields: [hostId], references: [id])

  // Performance indexes
  @@index([productId])
  @@index([adminId])
  @@index([createdAt])
}

// Énumérations pour les commentaires de validation
enum ValidationSection {
  GENERAL_INFO // Informations générales
  LOCATION // Localisation
  CHARACTERISTICS // Caractéristiques
  PRICING // Tarification
  EQUIPMENT // Équipements
  SERVICES // Services
  MEALS // Repas
  SECURITY // Sécurité
  PHOTOS // Photos
  ADDITIONAL_INFO // Informations complémentaires
}

enum ValidationCommentStatus {
  PENDING // En attente de résolution
  RESOLVED // Résolu
  ACKNOWLEDGED // Pris en compte mais pas encore résolu
}

model Discount {
  id            String   @id @default(cuid())
  productId     String
  product       Product  @relation(fields: [productId], references: [id], onDelete: Cascade)
  startDiscount DateTime
  endDiscount   DateTime
  price         Int
}

model Images {
  id      String    @id @default(cuid())
  img     String
  Product Product[] @relation("ImagesToProduct")
}

model SpecificPrices {
  id        String  @id @default(cuid())
  productId String
  day       BigInt
  price     BigInt
  active    BigInt
  product   Product @relation(fields: [productId], references: [id])
}

model SpecificRequest {
  id        String  @id @default(cuid())
  productId String
  name      String
  text      String
  product   Product @relation(fields: [productId], references: [id])
}

model Options {
  id        String  @id @default(cuid())
  productId String
  name      String
  price     BigInt
  type      BigInt
  product   Product @relation(fields: [productId], references: [id], onDelete: Cascade)
  Rent      Rent[]  @relation("OptionsToRent")
}

model Rent {
  id           String        @id @default(cuid())
  stripeId     String?
  productId    String
  userId       String
  numberPeople BigInt
  notes        BigInt
  accepted     Boolean
  prices       BigInt
  arrivingDate DateTime
  leavingDate  DateTime
  payment      PaymentStatus @default(NOT_PAID)
  product      Product       @relation(fields: [productId], references: [id], onDelete: Cascade)
  user         User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  options      Options[]     @relation("OptionsToRent")
  status       RentStatus    @default(WAITING)
  confirmed    Boolean       @default(false)
  Review       Review[]
  DisableRent  DisableRent[]

  PayRequest    PayRequest[]
  Chat          Chat[]
  RentRejection RentRejection?
  UserRating    UserRating[] // Nouvelle relation pour les notes bidirectionnelles
  extras        RentExtra[] // Relation avec les extras sélectionnés

  // Performance indexes
  @@index([userId])
  @@index([productId])
  @@index([status])
  @@index([payment])
  @@index([arrivingDate])
  @@index([leavingDate])
  @@index([arrivingDate, leavingDate])
  @@index([productId, arrivingDate, leavingDate])
  @@index([userId, status])
  @@index([confirmed])
}

model RentRejection {
  id         String    @id @default(cuid())
  rentId     String    @unique
  hostId     String // ID de l'hébergeur qui refuse
  guestId    String // ID de l'invité concerné
  reason     String // Raison du refus fournie par l'hébergeur
  message    String // Message détaillé du refus
  createdAt  DateTime  @default(now())
  resolved   Boolean   @default(false) // Pour savoir si l'admin a traité le refus
  resolvedAt DateTime? // Date de résolution par l'admin
  resolvedBy String? // ID de l'admin qui a résolu

  // Relations
  rent     Rent  @relation(fields: [rentId], references: [id], onDelete: Cascade)
  host     User  @relation("HostRejections", fields: [hostId], references: [id])
  guest    User  @relation("GuestRejections", fields: [guestId], references: [id])
  resolver User? @relation("AdminResolutions", fields: [resolvedBy], references: [id])
}

model UnAvailableProduct {
  id          String   @id @default(cuid())
  startDate   DateTime
  endDate     DateTime
  productId   String
  title       String   // Titre du blocage (obligatoire)
  description String?  // Description du blocage (optionnelle)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  product     Product  @relation(fields: [productId], references: [id], onDelete: Cascade)

  // Performance indexes
  @@index([productId])
  @@index([startDate, endDate])
}

model DisableRent {
  id        String   @id @default(cuid())
  startDate DateTime
  endDate   DateTime
  rentId    String
  rent      Rent     @relation(fields: [rentId], references: [id], onDelete: Cascade)
}

model Review {
  id             String   @id @default(cuid())
  productId      String
  title          String
  text           String
  grade          Int
  welcomeGrade   Int      @default(0)
  staff          Int      @default(0)
  comfort        Int      @default(0)
  equipment      Int      @default(0)
  cleaning       Int      @default(0)
  visitDate      DateTime
  publishDate    DateTime
  rentId         String
  approved       Boolean  @default(false)
  rentRelation   Rent     @relation(fields: [rentId], references: [id], onDelete: Cascade)
  product        Product  @relation(fields: [productId], references: [id])
  // Nouveaux champs pour identifier le type de review
  isAdminCreated Boolean  @default(false) // Si c'est un faux avis créé par un admin
  adminId        String? // ID de l'admin qui a créé le faux avis
  adminUser      User?    @relation("AdminReviews", fields: [adminId], references: [id])

  // Performance indexes
  @@index([productId])
  @@index([approved])
  @@index([publishDate])
  @@index([rentId])
}

// Nouveau modèle pour les notes bidirectionnelles (hôte <-> locataire)
model UserRating {
  id         String         @id @default(cuid())
  rentId     String
  raterId    String // Celui qui note
  ratedId    String // Celui qui est noté
  rating     Int // Note de 1 à 5
  comment    String? // Commentaire optionnel
  type       UserRatingType // HOST_TO_GUEST ou GUEST_TO_HOST
  approved   Boolean        @default(false) // Validation par admin
  adminId    String? // Admin qui a validé
  createdAt  DateTime       @default(now())
  approvedAt DateTime?

  // Relations
  rent  Rent  @relation(fields: [rentId], references: [id], onDelete: Cascade)
  rater User  @relation("GivenRatings", fields: [raterId], references: [id])
  rated User  @relation("ReceivedRatings", fields: [ratedId], references: [id])
  admin User? @relation("ApprovedRatings", fields: [adminId], references: [id])

  @@unique([rentId, raterId, ratedId, type]) // Un seul rating par type par réservation
}

enum UserRatingType {
  HOST_TO_GUEST
  GUEST_TO_HOST
}

model User {
  id                   String    @id @default(cuid())
  name                 String?
  email                String    @unique
  emailVerified        DateTime?
  emailToken           String?
  resetToken           String? // Pour la réinitialisation du mot de passe
  image                String? // Gardé pour compatibilité NextAuth
  profilePictureBase64 String? // Image de profil en base64
  createdAt            DateTime  @default(now())
  updatedAt            DateTime  @updatedAt
  info                 String?
  lastname             String?
  password             String?
  profilePicture       String?
  stripeCustomerId     String?
  roles                UserRole  @default(USER)

  // Champs de vérification
  isVerifiedTraveler Boolean @default(false) // Voyageur vérifié
  isAccountConfirmed Boolean @default(false) // Compte confirmé

  // Nouveaux champs pour les statistiques
  averageRating Float? // Note moyenne reçue en tant que locataire/hôte
  totalRatings  Int    @default(0) // Nombre total de notes reçues
  totalTrips    Int    @default(0) // Nombre total de voyages effectués

  accounts      Account[]
  Authenticator Authenticator[]
  Rent          Rent[]
  sessions      Session[]
  Product       Product[]
  Chat          Chat[]
  favorites     Favorite[]

  PayRequest PayRequest[]

  managedHotels hotel[] @relation(name: "managerUserId")

  staffHotels hotel[] @relation(name: "staff")

  // Relations pour les refus de réservation
  hostRejections   RentRejection[] @relation("HostRejections")
  guestRejections  RentRejection[] @relation("GuestRejections")
  adminResolutions RentRejection[] @relation("AdminResolutions")

  // Relations pour la validation des annonces
  adminComments     ValidationComment[] @relation("AdminComments")
  resolvedComments  ValidationComment[] @relation("CommentResolver")
  validationAsAdmin ValidationHistory[] @relation("ValidationAdmin")
  validationAsHost  ValidationHistory[] @relation("ValidationHost")

  // Nouvelles relations pour les reviews et ratings
  adminReviews    Review[]     @relation("AdminReviews") // Reviews créées par cet admin
  givenRatings    UserRating[] @relation("GivenRatings") // Notes données par cet utilisateur
  receivedRatings UserRating[] @relation("ReceivedRatings") // Notes reçues par cet utilisateur
  approvedRatings UserRating[] @relation("ApprovedRatings") // Notes validées par cet admin

  // Relations pour les services personnalisés
  personalIncludedServices IncludedService[]   @relation("UserIncludedServices") // Services inclus personnalisés
  personalExtras           ProductExtra[]      @relation("UserExtras") // Extras personnalisés
  personalHighlights       PropertyHighlight[] @relation("UserHighlights") // Points forts personnalisés

  // Relation pour les articles de blog
  authoredPosts Post[] @relation("AuthoredPosts") // Articles de blog créés par cet utilisateur

  // Relations pour le système de retrait
  paymentAccounts      PaymentAccount[]    @relation("UserPaymentAccounts") // Comptes de paiement enregistrés
  withdrawalRequests   WithdrawalRequest[] @relation("UserWithdrawals") // Demandes de retrait
  processedWithdrawals WithdrawalRequest[] @relation("ProcessedWithdrawals") // Retraits traités par cet admin

  // Relations pour le système de promotions
  createdPromotions ProductPromotion[]   @relation("CreatedPromotions") // Promotions créées par cet utilisateur
  pricingSettings   HostPricingSettings? @relation("HostPricingSettings") // Paramètres de tarification

  // Performance indexes
  @@index([roles])
  @@index([isVerifiedTraveler])
  @@index([isAccountConfirmed])
  @@index([stripeCustomerId])
  @@index([createdAt])
  // Admin search performance indexes
  @@index([name])
  @@index([lastname])
  @@index([email])
  @@index([createdAt, email])
  @@index([roles, createdAt])
}

model Account {
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([provider, providerAccountId])
}

model Session {
  sessionToken String   @unique
  userId       String
  expires      DateTime
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String
  expires    DateTime

  @@id([identifier, token])
}

model Authenticator {
  credentialID         String  @unique
  userId               String
  providerAccountId    String
  credentialPublicKey  String
  counter              Int
  credentialDeviceType String
  credentialBackedUp   Boolean
  transports           String?
  user                 User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([userId, credentialID])
}

model Chat {
  id         String   @unique @default(cuid())
  message    String
  userId     String
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  rentId     String
  rent       Rent     @relation(fields: [rentId], references: [id], onDelete: Cascade)
  host       Boolean
  dateSended DateTime
  read       Boolean  @default(false)
}

model PayRequest {
  id             String           @unique @default(cuid())
  userId         String
  user           User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  rentId         String
  rent           Rent             @relation(fields: [rentId], references: [id], onDelete: Cascade)
  PaymentRequest PaymentStatus
  prices         String
  notes          String
  method         PaymentMethod
  status         PaymentReqStatus
}

enum PaymentReqStatus {
  RECEIVED
  REFUSED
  DONE
}

enum PaymentMethod {
  SEPA_VIREMENT
  PRIPEO
  MOBILE_MONEY
  PAYPAL
  MONEYGRAM
  TAPTAP // Kept for backward compatibility
  INTERNATIONAL // Kept for backward compatibility
  OTHER // Kept for backward compatibility
}

enum UserRole {
  ADMIN
  BLOGWRITER
  HOST
  HOST_VERIFIED
  HOST_MANAGER
  USER
}

enum PaymentStatus {
  NOT_PAID
  CLIENT_PAID
  MID_TRANSFER_REQ
  MID_TRANSFER_DONE
  REST_TRANSFER_REQ
  REST_TRANSFER_DONE
  FULL_TRANSFER_REQ
  FULL_TRANSFER_DONE
  REFUNDED
  DISPUTE
}

enum RentStatus {
  WAITING
  RESERVED
  CHECKIN
  CHECKOUT
  CANCEL
}

enum ProductValidation {
  NotVerified
  Approve
  Refused
  RecheckRequest
  ModificationPending // Product has a pending modification draft
}

enum DayEnum {
  Monday
  Tuesday
  Wednesday
  Thursday
  Friday
  Saturday
  Sunday
}

model Favorite {
  id        String   @id @default(cuid())
  userId    String
  productId String
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  product   Product  @relation(fields: [productId], references: [id], onDelete: Cascade)

  @@unique([userId, productId])
}

model hotel {
  id     String    @id @default(cuid())
  userId String
  user   User      @relation(name: "managerUserId", fields: [userId], references: [id], onDelete: Cascade)
  staff  User[]    @relation(name: "staff")
  room   Product[]
  number String
  adress String
  name   String
}

model PromotedProduct {
  id        String   @id @default(cuid())
  active    Boolean  @default(false)
  start     DateTime
  end       DateTime
  productId String
  product   Product  @relation(fields: [productId], references: [id], onDelete: Cascade)
}

model NearbyPlace {
  id        String  @id @default(cuid())
  name      String
  distance  Int // en mètres
  duration  Int // en minutes
  transport String // à pied, en voiture, etc.
  productId String
  product   Product @relation(fields: [productId], references: [id], onDelete: Cascade)
}

model TransportOption {
  id          String  @id @default(cuid())
  name        String
  description String?
  productId   String
  product     Product @relation(fields: [productId], references: [id], onDelete: Cascade)
}

model PropertyInfo {
  id                String  @id @default(cuid())
  hasStairs         Boolean @default(false)
  hasElevator       Boolean @default(false)
  hasHandicapAccess Boolean @default(false)
  hasPetsOnProperty Boolean @default(false)
  additionalNotes   String?
  productId         String  @unique
  product           Product @relation(fields: [productId], references: [id], onDelete: Cascade)
}

model Post {
  id              String   @id @default(cuid())
  title           String   @unique
  content         String   @db.Text
  image           String?
  // SEO fields
  metaTitle       String?
  metaDescription String?
  keywords        String?
  slug            String?  @unique
  // Author relationship
  authorId        String   @default("cmdqcrvp20003jp04si03b7sr")
  author          User     @relation("AuthoredPosts", fields: [authorId], references: [id], onDelete: Cascade)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
}

model SpecialPrices {
  id         String    @id @default(cuid())
  pricesMga  String
  pricesEuro String
  day        DayEnum[]
  startDate  DateTime?
  endDate    DateTime?
  activate   Boolean   @default(true)
  productId  String
  product    Product   @relation(fields: [productId], references: [id], onDelete: Cascade)

  // Performance indexes
  @@index([productId])
  @@index([activate])
  @@index([startDate, endDate])
}

// Configuration des commissions (globale pour la plateforme - LEGACY)
// DEPRECATED: Utilisez le modèle Commission à la place
model CommissionSettings {
  id                    String   @id @default(cuid())
  // Commission côté hébergeur
  hostCommissionRate    Float    @default(0.0) // Taux en pourcentage (ex: 5.0 pour 5%)
  hostCommissionFixed   Float    @default(0.0) // Frais fixes en euros
  // Commission côté client
  clientCommissionRate  Float    @default(0.0) // Taux en pourcentage
  clientCommissionFixed Float    @default(0.0) // Frais fixes en euros
  // Metadata
  isActive              Boolean  @default(true)
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt
  createdBy             String? // ID de l'admin qui a créé

  @@map("commission_settings")
}

// Nouvelle configuration des commissions (par type de logement)
model Commission {
  id          String   @id @default(cuid())

  // Identification
  title       String   // Ex: "Commission Appartement Standard"
  description String?  // Description détaillée optionnelle

  // Commission côté hébergeur (déduite du prix de base)
  hostCommissionRate  Float @default(0.0) // Taux en pourcentage (ex: 5.0 pour 5%)
  hostCommissionFixed Float @default(0.0) // Frais fixes en euros

  // Commission côté client (ajoutée au prix de base)
  clientCommissionRate  Float @default(0.0) // Taux en pourcentage
  clientCommissionFixed Float @default(0.0) // Frais fixes en euros

  // Relation avec le type de logement (one-to-one)
  typeRentId String   @unique
  typeRent   TypeRent @relation(fields: [typeRentId], references: [id], onDelete: Cascade)

  // Metadata
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  createdBy String?  // ID de l'admin qui a créé

  @@map("commissions")
  @@index([typeRentId])
  @@index([isActive])
  @@index([createdAt])
}

// ============================================
// WITHDRAWAL SYSTEM MODELS
// ============================================

// Comptes de paiement enregistrés par les hôtes
model PaymentAccount {
  id        String        @id @default(cuid())
  userId    String
  user      User          @relation("UserPaymentAccounts", fields: [userId], references: [id], onDelete: Cascade)

  // Type de moyen de paiement
  method    PaymentMethod

  // Informations communes
  accountHolderName String // Nom du titulaire du compte

  // Informations spécifiques selon le moyen de paiement
  // SEPA_VIREMENT
  iban String? // IBAN pour SEPA

  // PRIPEO
  cardNumber String? // Numéro de carte Pripeo
  cardEmail  String? // Email associé à la carte Pripeo

  // MOBILE_MONEY
  mobileNumber String? // Numéro de téléphone mobile (format: +261 XX XX XXX XX)

  // PAYPAL
  paypalUsername String? // Nom d'utilisateur PayPal
  paypalEmail    String? // Email PayPal
  paypalPhone    String? // Téléphone PayPal (avec code pays)
  paypalIban     String? // IBAN PayPal (si applicable)

  // MONEYGRAM
  moneygramFullName String? // Nom complet pour MoneyGram
  moneygramPhone    String? // Téléphone MoneyGram

  // Validation et statut
  isValidated Boolean  @default(false) // Validé par un admin
  isDefault   Boolean  @default(false) // Compte par défaut pour les retraits
  validatedAt DateTime? // Date de validation
  validatedBy String? // ID de l'admin qui a validé

  // Metadata
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  withdrawalRequests WithdrawalRequest[] @relation("AccountWithdrawals")

  @@index([userId])
  @@index([method])
  @@index([isValidated])
  @@index([isDefault])
  @@map("payment_accounts")
}

// Demandes de retrait
model WithdrawalRequest {
  id     String @id @default(cuid())
  userId String
  user   User   @relation("UserWithdrawals", fields: [userId], references: [id], onDelete: Cascade)

  // Montant et type de retrait
  amount           Float  // Montant demandé en euros
  availableBalance Float  // Solde disponible au moment de la demande
  withdrawalType   WithdrawalType // 50% ou 100%

  // Méthode de paiement choisie
  paymentAccountId String?
  paymentAccount   PaymentAccount? @relation("AccountWithdrawals", fields: [paymentAccountId], references: [id])
  paymentMethod    PaymentMethod // Copie pour historique

  // Informations de paiement (copie au moment de la demande)
  paymentDetails Json // Stocke les détails du compte de paiement

  // Statut et workflow
  status WithdrawalStatus @default(PENDING)

  // Notes et commentaires
  notes        String? // Notes de l'hébergeur
  adminNotes   String? // Notes internes de l'admin
  rejectionReason String? // Raison du refus si applicable

  // Traitement par l'admin
  processedBy String? // ID de l'admin qui a traité
  processor   User?   @relation("ProcessedWithdrawals", fields: [processedBy], references: [id])
  processedAt DateTime? // Date de traitement
  paidAt      DateTime? // Date de paiement effectif

  // Metadata
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([status])
  @@index([createdAt])
  @@index([processedAt])
  @@map("withdrawal_requests")
}

// Type de retrait (50% ou 100%)
enum WithdrawalType {
  PARTIAL_50  // 50% du montant (selon contrat)
  FULL_100    // 100% du montant
}

// Statut de la demande de retrait
enum WithdrawalStatus {
  PENDING           // En attente de traitement
  ACCOUNT_VALIDATION // En attente de validation du compte
  APPROVED          // Approuvée, en attente de paiement
  PAID              // Payée
  REJECTED          // Refusée
  CANCELLED         // Annulée par l'hébergeur
}

// ============================================
// PROMOTION SYSTEM MODELS
// ============================================

// Promotions sur les produits (réductions temporaires)
model ProductPromotion {
  id        String   @id @default(cuid())
  productId String
  product   Product  @relation("ProductPromotions", fields: [productId], references: [id], onDelete: Cascade)

  // Détails de la promotion
  discountPercentage Float // Pourcentage de réduction (ex: 10 pour -10%)
  startDate          DateTime
  endDate            DateTime

  // Gestion
  isActive    Boolean @default(true)
  createdById String // ID de l'ADMIN/HOST/HOST_MANAGER qui a créé
  createdBy   User    @relation("CreatedPromotions", fields: [createdById], references: [id])

  // Désactivation automatique (pour gestion des chevauchements)
  replacedById       String?            @unique
  replacedBy         ProductPromotion?  @relation("PromotionReplacement", fields: [replacedById], references: [id], onDelete: SetNull)
  replacedPromotions ProductPromotion[] @relation("PromotionReplacement")

  // Metadata
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Performance indexes
  @@index([productId])
  @@index([isActive])
  @@index([startDate, endDate])
  @@index([productId, isActive, startDate, endDate])
}

// Paramètres de tarification par hôte
model HostPricingSettings {
  id     String @id @default(cuid())
  userId String @unique // Un seul setting par hôte
  user   User   @relation("HostPricingSettings", fields: [userId], references: [id], onDelete: Cascade)

  // Gestion du chevauchement Promotions + SpecialPrices
  promotionPriority PricingPriority @default(PROMOTION_FIRST)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
}

// Priorité de tarification
enum PricingPriority {
  PROMOTION_FIRST     // Promo s'applique, SpecialPrice ignoré
  SPECIAL_PRICE_FIRST // SpecialPrice remplace tout
  MOST_ADVANTAGEOUS   // Le plus avantageux pour le client
  STACK_DISCOUNTS     // Cumuler les deux réductions
}
