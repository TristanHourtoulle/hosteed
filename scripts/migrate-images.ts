/**
 * Script de migration des images pour la production
 * Convertit toutes les images base64 existantes en format WebP optimis√©
 *
 * Usage: npx tsx scripts/migrate-images.ts
 *
 * IMPORTANT: Ex√©cuter ce script SEULEMENT en production apr√®s avoir d√©ploy√©
 * les nouvelles optimisations d'images.
 */

import { PrismaClient } from '@prisma/client'
import { optimizeImageForDatabase } from '../src/lib/services/image-optimization.service'

const prisma = new PrismaClient()

interface MigrationStats {
  total: number
  processed: number
  optimized: number
  errors: number
  spaceSaved: number
}

async function migrateImages() {
  console.log('üöÄ D√©but de la migration des images vers WebP...')
  console.log("‚ö†Ô∏è  Cette op√©ration peut prendre du temps selon le nombre d'images")

  const stats: MigrationStats = {
    total: 0,
    processed: 0,
    optimized: 0,
    errors: 0,
    spaceSaved: 0,
  }

  try {
    // Compter le nombre total d'images √† migrer
    const totalImages = await prisma.images.count({
      where: {
        img: {
          contains: 'data:image/',
        },
      },
    })

    if (totalImages === 0) {
      console.log('‚úÖ Aucune image √† migrer trouv√©e.')
      return
    }

    stats.total = totalImages
    console.log(`üì∏ ${totalImages} images trouv√©es √† optimiser`)

    // Traiter les images par batch de 10 pour √©viter la surcharge m√©moire
    const batchSize = 10
    let offset = 0

    while (offset < totalImages) {
      console.log(
        `\nüì¶ Traitement du batch ${Math.floor(offset / batchSize) + 1}/${Math.ceil(totalImages / batchSize)}`
      )

      const images = await prisma.images.findMany({
        where: {
          img: {
            contains: 'data:image/',
          },
        },
        select: {
          id: true,
          img: true,
          Product: {
            select: {
              id: true,
            },
          },
        },
        skip: offset,
        take: batchSize,
      })

      for (const image of images) {
        try {
          stats.processed++

          if (!image.img || !image.img.startsWith('data:image/')) {
            console.log(`‚è≠Ô∏è  Image ${image.id} - Format non support√©, ignor√©e`)
            continue
          }

          // Calculer la taille avant optimisation
          const originalSize = Buffer.from(image.img.split(',')[1] || '', 'base64').length

          // Optimiser l'image
          const optimizedImage = await optimizeImageForDatabase(image.img)

          // Calculer la taille apr√®s optimisation
          const optimizedSize = Buffer.from(optimizedImage.split(',')[1] || '', 'base64').length
          const savedBytes = originalSize - optimizedSize
          const savedPercent = ((savedBytes / originalSize) * 100).toFixed(1)

          // Mettre √† jour en base de donn√©es
          await prisma.images.update({
            where: { id: image.id },
            data: { img: optimizedImage },
          })

          stats.optimized++
          stats.spaceSaved += savedBytes

          const productIds = image.Product.map(p => p.id).join(', ') || 'no-product'
          console.log(
            `‚úÖ Image ${image.id} (Products: ${productIds}) - Optimis√©e (-${savedPercent}%)`
          )

          // Pause courte pour √©viter la surcharge
          await new Promise(resolve => setTimeout(resolve, 100))
        } catch (error) {
          stats.errors++
          console.error(
            `‚ùå Erreur image ${image.id}:`,
            error instanceof Error ? error.message : error
          )

          // Continuer malgr√© les erreurs individuelles
          continue
        }
      }

      offset += batchSize

      // Afficher les statistiques interm√©diaires
      const progress = ((offset / totalImages) * 100).toFixed(1)
      const spaceSavedMB = (stats.spaceSaved / (1024 * 1024)).toFixed(2)
      console.log(
        `\nüìä Progression: ${progress}% | Optimis√©es: ${stats.optimized} | Erreurs: ${stats.errors} | Espace √©conomis√©: ${spaceSavedMB} MB`
      )
    }

    // Statistiques finales
    console.log('\nüéâ Migration termin√©e !')
    console.log('üìä Statistiques finales:')
    console.log(`   ‚Ä¢ Images trait√©es: ${stats.processed}/${stats.total}`)
    console.log(`   ‚Ä¢ Images optimis√©es: ${stats.optimized}`)
    console.log(`   ‚Ä¢ Erreurs: ${stats.errors}`)
    console.log(`   ‚Ä¢ Espace √©conomis√©: ${(stats.spaceSaved / (1024 * 1024)).toFixed(2)} MB`)

    if (stats.optimized > 0) {
      const avgSavings = (stats.spaceSaved / stats.optimized / 1024).toFixed(1)
      console.log(`   ‚Ä¢ √âconomie moyenne par image: ${avgSavings} KB`)
    }

    // V√©rification finale
    const remainingImages = await prisma.images.count({
      where: {
        img: {
          contains: 'data:image/',
          not: { contains: 'data:image/webp' },
        },
      },
    })

    if (remainingImages > 0) {
      console.log(
        `\n‚ö†Ô∏è  ${remainingImages} images non-WebP restantes (probablement des erreurs ou formats non support√©s)`
      )
    } else {
      console.log('\n‚úÖ Toutes les images ont √©t√© converties en WebP !')
    }
  } catch (error) {
    console.error('üí• Erreur fatale lors de la migration:', error)
    throw error
  } finally {
    await prisma.$disconnect()
  }
}

// Fonction de v√©rification avant migration
async function verifyEnvironment() {
  console.log("üîç V√©rification de l'environnement...")

  // V√©rifier que l'optimisation d'images est activ√©e
  const imageOptimizationEnabled = process.env.ENABLE_IMAGE_OPTIMIZATION === 'true'
  if (!imageOptimizationEnabled) {
    console.error(
      "‚ùå ENABLE_IMAGE_OPTIMIZATION doit √™tre activ√© dans les variables d'environnement"
    )
    process.exit(1)
  }

  // V√©rifier la connexion √† la base de donn√©es
  try {
    await prisma.$queryRaw`SELECT 1`
    console.log('‚úÖ Connexion √† la base de donn√©es OK')
  } catch (error) {
    console.error('‚ùå Impossible de se connecter √† la base de donn√©es:', error)
    process.exit(1)
  }

  // V√©rifier l'espace disque disponible (estimation)
  const totalImages = await prisma.images.count()

  console.log(`üìä ${totalImages} images trouv√©es en base de donn√©es`)
  console.log(
    "‚ö†Ô∏è  Assurez-vous d'avoir suffisamment d'espace disque (environ 30% de libre recommand√©)"
  )

  return true
}

// Fonction principale avec gestion d'erreurs
async function main() {
  try {
    await verifyEnvironment()

    // Demander confirmation en production
    if (process.env.NODE_ENV === 'production') {
      console.log('\nüö® ATTENTION: Vous √™tes en PRODUCTION')
      console.log('Cette migration va modifier toutes les images en base de donn√©es.')
      console.log("Assurez-vous d'avoir fait une sauvegarde r√©cente !")
      console.log('\nPour continuer, d√©finissez la variable CONFIRM_MIGRATION=true')

      if (process.env.CONFIRM_MIGRATION !== 'true') {
        console.log('‚ùå Migration annul√©e (CONFIRM_MIGRATION != true)')
        process.exit(0)
      }
    }

    await migrateImages()
  } catch (error) {
    console.error('üí• √âchec de la migration:', error)
    process.exit(1)
  }
}

// Gestion des signaux pour arr√™t propre
process.on('SIGINT', async () => {
  console.log("\n‚èπÔ∏è  Migration interrompue par l'utilisateur")
  await prisma.$disconnect()
  process.exit(0)
})

process.on('SIGTERM', async () => {
  console.log('\n‚èπÔ∏è  Migration interrompue par le syst√®me')
  await prisma.$disconnect()
  process.exit(0)
})

// Ex√©cution du script
if (require.main === module) {
  main()
}

export { migrateImages, verifyEnvironment }
