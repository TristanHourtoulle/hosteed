/**
 * Script de v√©rification des optimisations d√©ploy√©es
 * V√©rifie que toutes les optimisations fonctionnent correctement en production
 * 
 * Usage: npx tsx scripts/verify-optimizations.ts
 */

import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

interface VerificationResult {
  category: string;
  status: 'success' | 'warning' | 'error';
  message: string;
  details?: any;
}

const results: VerificationResult[] = [];

async function verifyDatabaseIndexes() {
  console.log('üîç V√©rification des index de base de donn√©es...');
  
  try {
    // V√©rifier que les index critiques existent
    const indexes = await prisma.$queryRaw<Array<{ indexname: string, tablename: string }>>`
      SELECT indexname, tablename 
      FROM pg_indexes 
      WHERE schemaname = 'public' 
      AND indexname LIKE 'idx_%'
      ORDER BY tablename, indexname;
    `;
    
    const criticalIndexes = [
      'idx_images_product_lookup',
      'idx_product_complex_search',
      'idx_rent_availability_check',
      'idx_special_prices_active_lookup'
    ];
    
    const existingIndexes = indexes.map(idx => idx.indexname);
    const missingIndexes = criticalIndexes.filter(idx => !existingIndexes.includes(idx));
    
    if (missingIndexes.length === 0) {
      results.push({
        category: 'Database Indexes',
        status: 'success',
        message: `Tous les index critiques sont pr√©sents (${existingIndexes.length} index trouv√©s)`,
        details: { totalIndexes: existingIndexes.length, criticalIndexes: criticalIndexes.length }
      });
    } else {
      results.push({
        category: 'Database Indexes',
        status: 'error',
        message: `Index manquants: ${missingIndexes.join(', ')}`,
        details: { missing: missingIndexes, existing: existingIndexes }
      });
    }
    
  } catch (error) {
    results.push({
      category: 'Database Indexes',
      status: 'error',
      message: 'Impossible de v√©rifier les index',
      details: error
    });
  }
}

async function verifyImageOptimization() {
  console.log('üñºÔ∏è V√©rification de l\'optimisation des images...');
  
  try {
    // Compter les images WebP vs autres formats
    const totalImages = await prisma.images.count();
    
    const webpImages = await prisma.images.count({
      where: { 
        img: { contains: 'data:image/webp' }
      }
    });
    
    const oldFormatImages = await prisma.images.count({
      where: {
        img: {
          contains: 'data:image/',
          not: { contains: 'data:image/webp' }
        }
      }
    });
    
    const webpPercentage = totalImages > 0 ? ((webpImages / totalImages) * 100).toFixed(1) : '0';
    
    if (oldFormatImages === 0) {
      results.push({
        category: 'Image Optimization',
        status: 'success',
        message: `Toutes les images sont optimis√©es (${webpImages} images WebP)`,
        details: { total: totalImages, webp: webpImages, webpPercentage: `${webpPercentage}%` }
      });
    } else if (webpImages > oldFormatImages) {
      results.push({
        category: 'Image Optimization',
        status: 'warning',
        message: `Migration en cours: ${webpPercentage}% des images sont optimis√©es`,
        details: { total: totalImages, webp: webpImages, oldFormat: oldFormatImages, webpPercentage: `${webpPercentage}%` }
      });
    } else {
      results.push({
        category: 'Image Optimization',
        status: 'error',
        message: `Migration n√©cessaire: seulement ${webpPercentage}% des images sont optimis√©es`,
        details: { total: totalImages, webp: webpImages, oldFormat: oldFormatImages, webpPercentage: `${webpPercentage}%` }
      });
    }
    
  } catch (error) {
    results.push({
      category: 'Image Optimization',
      status: 'error',
      message: 'Impossible de v√©rifier l\'optimisation des images',
      details: error
    });
  }
}

async function verifyPerformanceQueries() {
  console.log('‚ö° V√©rification des performances des requ√™tes...');
  
  try {
    // Test de performance sur une requ√™te critique
    const startTime = Date.now();
    
    const products = await prisma.product.findMany({
      where: { validate: 'Approve' },
      include: {
        img: {
          take: 1
        },
        user: {
          select: { name: true, profilePicture: true }
        }
      },
      take: 10
    });
    
    const queryTime = Date.now() - startTime;
    
    if (queryTime < 200) {
      results.push({
        category: 'Query Performance',
        status: 'success',
        message: `Requ√™te produits optimis√©e (${queryTime}ms)`,
        details: { queryTime, productsReturned: products.length }
      });
    } else if (queryTime < 500) {
      results.push({
        category: 'Query Performance',
        status: 'warning',
        message: `Performances correctes mais am√©liorables (${queryTime}ms)`,
        details: { queryTime, productsReturned: products.length }
      });
    } else {
      results.push({
        category: 'Query Performance',
        status: 'error',
        message: `Requ√™te trop lente (${queryTime}ms) - V√©rifier les index`,
        details: { queryTime, productsReturned: products.length }
      });
    }
    
  } catch (error) {
    results.push({
      category: 'Query Performance',
      status: 'error',
      message: 'Impossible de tester les performances des requ√™tes',
      details: error
    });
  }
}

async function verifyEnvironmentVariables() {
  console.log('üîß V√©rification des variables d\'environnement...');
  
  const requiredVars = [
    'DATABASE_URL',
    'NEXTAUTH_URL',
    'AUTH_SECRET'
  ];
  
  const optimizationVars = [
    'ENABLE_IMAGE_OPTIMIZATION',
    'ENABLE_PERFORMANCE_MONITORING',
    'ENABLE_ANALYTICS',
    'REDIS_URL'
  ];
  
  const missingRequired = requiredVars.filter(varName => !process.env[varName]);
  const enabledOptimizations = optimizationVars.filter(varName => process.env[varName] === 'true');
  
  if (missingRequired.length > 0) {
    results.push({
      category: 'Environment Variables',
      status: 'error',
      message: `Variables requises manquantes: ${missingRequired.join(', ')}`,
      details: { missing: missingRequired }
    });
  } else {
    results.push({
      category: 'Environment Variables',
      status: 'success',
      message: `Variables requises pr√©sentes. Optimisations actives: ${enabledOptimizations.length}`,
      details: { enabledOptimizations }
    });
  }
}

async function verifyRedisConnection() {
  console.log('üöÄ V√©rification de la connexion Redis...');
  
  const redisEnabled = process.env.ENABLE_REDIS_CACHE === 'true';
  const redisUrl = process.env.REDIS_URL;
  
  if (!redisEnabled) {
    results.push({
      category: 'Redis Cache',
      status: 'warning',
      message: 'Cache Redis d√©sactiv√©',
      details: { enabled: false }
    });
    return;
  }
  
  if (!redisUrl) {
    results.push({
      category: 'Redis Cache',
      status: 'error',
      message: 'REDIS_URL manquant alors que le cache est activ√©',
      details: { enabled: true, url: null }
    });
    return;
  }
  
  try {
    // Test simple de connexion Redis si le module est disponible
    const { createClient } = require('redis');
    const client = createClient({ url: redisUrl });
    
    await client.connect();
    await client.ping();
    await client.disconnect();
    
    results.push({
      category: 'Redis Cache',
      status: 'success',
      message: 'Connexion Redis fonctionnelle',
      details: { enabled: true, url: redisUrl.replace(/\/\/.*@/, '//***@') }
    });
    
  } catch (error) {
    results.push({
      category: 'Redis Cache',
      status: 'error',
      message: 'Impossible de se connecter √† Redis',
      details: { enabled: true, error: error instanceof Error ? error.message : error }
    });
  }
}

async function generateReport() {
  console.log('\nüìä G√©n√©ration du rapport de v√©rification...');
  
  const successCount = results.filter(r => r.status === 'success').length;
  const warningCount = results.filter(r => r.status === 'warning').length;
  const errorCount = results.filter(r => r.status === 'error').length;
  
  console.log('\n='.repeat(60));
  console.log('üìã RAPPORT DE V√âRIFICATION DES OPTIMISATIONS');
  console.log('='.repeat(60));
  
  console.log(`\nüìà R√©sum√©: ${successCount} ‚úÖ | ${warningCount} ‚ö†Ô∏è | ${errorCount} ‚ùå\n`);
  
  results.forEach(result => {
    const icon = result.status === 'success' ? '‚úÖ' : result.status === 'warning' ? '‚ö†Ô∏è' : '‚ùå';
    console.log(`${icon} ${result.category}: ${result.message}`);
    
    if (result.details && typeof result.details === 'object') {
      Object.entries(result.details).forEach(([key, value]) => {
        console.log(`   ‚îî‚îÄ ${key}: ${JSON.stringify(value)}`);
      });
    }
    console.log('');
  });
  
  // Score global
  const totalChecks = results.length;
  const score = ((successCount * 2 + warningCount) / (totalChecks * 2)) * 100;
  
  console.log('='.repeat(60));
  console.log(`üéØ Score d'optimisation: ${score.toFixed(1)}%`);
  
  if (score >= 90) {
    console.log('üéâ Excellent ! Toutes les optimisations sont bien configur√©es.');
  } else if (score >= 70) {
    console.log('üëç Bon ! Quelques optimisations mineures possibles.');
  } else if (score >= 50) {
    console.log('‚ö†Ô∏è  Attention ! Plusieurs optimisations n√©cessitent votre attention.');
  } else {
    console.log('üö® Critique ! Des optimisations importantes sont manquantes.');
  }
  
  console.log('='.repeat(60));
  
  return {
    score,
    summary: { success: successCount, warning: warningCount, error: errorCount },
    results
  };
}

async function main() {
  try {
    console.log('üîç D√©marrage de la v√©rification des optimisations...\n');
    
    await verifyEnvironmentVariables();
    await verifyDatabaseIndexes();
    await verifyImageOptimization();
    await verifyPerformanceQueries();
    await verifyRedisConnection();
    
    const report = await generateReport();
    
    // Sortir avec un code d'erreur si des probl√®mes critiques sont d√©tect√©s
    if (report.summary.error > 0) {
      console.log('\n‚ùå Des erreurs critiques ont √©t√© d√©tect√©es. Veuillez les corriger avant de continuer.');
      process.exit(1);
    } else if (report.summary.warning > 0) {
      console.log('\n‚ö†Ô∏è  Des avertissements ont √©t√© d√©tect√©s. Recommandation: corriger avant la mise en production.');
    } else {
      console.log('\n‚úÖ Toutes les v√©rifications sont pass√©es avec succ√®s !');
    }
    
  } catch (error) {
    console.error('üí• Erreur lors de la v√©rification:', error);
    process.exit(1);
  } finally {
    await prisma.$disconnect();
  }
}

// Ex√©cution du script
if (require.main === module) {
  main();
}

export { verifyDatabaseIndexes, verifyImageOptimization, verifyPerformanceQueries };